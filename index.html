<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>zscä¸¨ 3D é­”æ–¹ Pro</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body { 
            margin: 0; overflow: hidden; background-color: #121212; 
            font-family: 'DIN Alternate', 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent; touch-action: none; color: white;
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; cursor: grab; z-index: 1; }
        #canvas-container:active { cursor: grabbing; }

        /* --- é¡¶éƒ¨ HUD --- */
        #top-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px 20px; box-sizing: border-box;
            display: flex; justify-content: space-between; align-items: center;
            pointer-events: none; z-index: 10;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
        }
        .stat-box { display: flex; flex-direction: column; align-items: center; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .stat-label { font-size: 10px; opacity: 0.7; letter-spacing: 1px; margin-bottom: 2px; }
        .stat-value { font-size: 24px; font-weight: 700; font-variant-numeric: tabular-nums; }
        #timer { color: #4db8ff; }
        #moves { color: #ffb84d; }

        /* --- èƒœåˆ©æç¤º --- */
        #win-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            font-size: 40px; font-weight: 900; color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            pointer-events: none; opacity: 0; z-index: 20;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #win-overlay.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        /* --- åº•éƒ¨æ§åˆ¶æ  --- */
        #bottom-bar {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            display: flex; justify-content: center; gap: 15px;
            pointer-events: none; z-index: 10;
            padding-bottom: env(safe-area-inset-bottom);
            flex-wrap: wrap;
        }
        .btn {
            pointer-events: auto; background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2); color: white;
            width: 50px; height: 50px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 20px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            flex-shrink: 0;
        }
        .btn:active { transform: scale(0.9); background: rgba(255,255,255,0.25); }
        .btn.main { width: auto; padding: 0 20px; border-radius: 25px; font-size: 14px; font-weight: bold; letter-spacing: 1px; }
        
        /* ç§»åŠ¨ç«¯é€‚é…ï¼šå°å±å¹•æ—¶æŒ‰é’®ç¼©å° */
        @media (max-width: 480px) {
            .btn { width: 45px; height: 45px; font-size: 18px; }
            .btn.main { padding: 0 15px; font-size: 13px; }
            #bottom-bar { gap: 10px; bottom: 20px; }
        }
        
        /* éå¸¸å°çš„å±å¹•ï¼šè¿›ä¸€æ­¥ç¼©å°æŒ‰é’®å¹¶è°ƒæ•´ä½ç½® */
        @media (max-width: 360px) {
            .btn { width: 40px; height: 40px; font-size: 16px; }
            .btn.main { padding: 0 12px; font-size: 12px; }
            #bottom-bar { gap: 8px; bottom: 15px; }
        }

        /* å¼•å¯¼æ–‡å­— */
        #guide {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.3); font-size: 14px; pointer-events: none; text-align: center;
            transition: opacity 0.5s;
        }
        
        /* é¢ å€’æ¨¡å¼æç¤º */
        #flip-notice {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            color: #ff6b6b; font-size: 12px; pointer-events: none; 
            background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 10px;
            opacity: 0; transition: opacity 0.3s; z-index: 15;
        }
        #flip-notice.show { opacity: 1; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="top-bar">
        <div class="stat-box">
            <span class="stat-label">TIME</span>
            <span class="stat-value" id="timer">00:00.00</span>
        </div>
        <div class="stat-box">
            <span class="stat-label">MOVES</span>
            <span class="stat-value" id="moves">0</span>
        </div>
    </div>

    <div id="guide">æ‹–æ‹½æ—‹è½¬è§†è§’<br>æ»‘åŠ¨é­”æ–¹æ“ä½œ</div>
    <div id="win-overlay">SOLVED!</div>
    <div id="flip-notice">é¢ å€’æ¨¡å¼</div>

    <div id="bottom-bar">
        <button class="btn" onclick="undoMove()">â†©ï¸</button>
        <button class="btn" onclick="flipCube()">â†•ï¸</button>
        <button class="btn main" onclick="scramble()">ğŸ² æ‰“ä¹±</button>
        <button class="btn" onclick="resetGame()">ğŸ”„</button>
    </div>

    <div id="canvas-container"></div>

<script>
    // --- é…ç½® ---
    const CONFIG = {
        cubeSize: 1, spacing: 0.02, animSpeed: 250,
        colors: { base:0x111111, u:0xFFFFFF, d:0xFFD500, f:0x009E60, b:0x0051BA, r:0xC41E3A, l:0xFF5800 }
    };
    const TOTAL_SIZE = CONFIG.cubeSize + CONFIG.spacing;

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, controls;
    let cubes = [];
    let pivot = new THREE.Object3D();
    let cubeGroup = new THREE.Group(); // ç”¨äºæ•´ä½“æ—‹è½¬é­”æ–¹çš„ç»„
    
    // çŠ¶æ€
    let isAnimating = false;
    let isScrambling = false;
    let isSolved = true;
    let isFlipped = false; // æ ‡è®°æ˜¯å¦å¤„äºé¢ å€’æ¨¡å¼
    let moveHistory = [];
    let moveCount = 0;
    
    // è®¡æ—¶å™¨
    let startTime = 0;
    let timerInterval = null;
    let isTimerRunning = false;

    // äº¤äº’
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let startPoint = null;
    let selectedCube = null;
    let selectedNormal = null;

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x121212);
        scene.add(pivot);
        scene.add(cubeGroup); // å°†é­”æ–¹ç»„æ·»åŠ åˆ°åœºæ™¯

        camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 7);
        camera.lookAt(0,0,0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.enablePan = false;
        controls.minDistance = 3; controls.maxDistance = 15;

        // ç¯å…‰
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dl = new THREE.DirectionalLight(0xffffff, 1);
        dl.position.set(10, 20, 10); scene.add(dl);
        const fl = new THREE.DirectionalLight(0xffffff, 0.4);
        fl.position.set(-10, -10, -10); scene.add(fl);

        createCube();

        const cvs = renderer.domElement;
        cvs.addEventListener('pointerdown', onPointerDown);
        cvs.addEventListener('pointermove', onPointerMove);
        cvs.addEventListener('pointerup', onPointerUp);
        cvs.addEventListener('pointerleave', onPointerUp);
        window.addEventListener('resize', onResize);
    }

    // --- è®¡æ—¶å™¨é€»è¾‘ ---
    function startTimer() {
        if (isTimerRunning || isSolved) return;
        isTimerRunning = true;
        startTime = Date.now();
        document.getElementById('guide').style.opacity = '0';
        
        timerInterval = setInterval(() => {
            const delta = Date.now() - startTime;
            const min = Math.floor(delta / 60000).toString().padStart(2, '0');
            const sec = Math.floor((delta % 60000) / 1000).toString().padStart(2, '0');
            const ms = Math.floor((delta % 1000) / 10).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${min}:${sec}.${ms}`;
        }, 30);
    }

    function stopTimer() {
        isTimerRunning = false;
        clearInterval(timerInterval);
    }

    function resetUI() {
        stopTimer();
        document.getElementById('timer').innerText = "00:00.00";
        document.getElementById('moves').innerText = "0";
        document.getElementById('win-overlay').classList.remove('show');
        document.getElementById('guide').style.opacity = '1';
        moveCount = 0;
    }

    // --- æ ¸å¿ƒé€»è¾‘ ---

    function createCube() {
        cubes.forEach(c => cubeGroup.remove(c));
        cubes = [];
        const geo = new THREE.BoxGeometry(CONFIG.cubeSize, CONFIG.cubeSize, CONFIG.cubeSize);
        const edgeGeo = new THREE.EdgesGeometry(geo);

        for (let x=-1; x<=1; x++) {
            for (let y=-1; y<=1; y++) {
                for (let z=-1; z<=1; z++) {
                    const mats = [
                        getMat(x===1?CONFIG.colors.r:CONFIG.colors.base),
                        getMat(x===-1?CONFIG.colors.l:CONFIG.colors.base),
                        getMat(y===1?CONFIG.colors.u:CONFIG.colors.base),
                        getMat(y===-1?CONFIG.colors.d:CONFIG.colors.base),
                        getMat(z===1?CONFIG.colors.f:CONFIG.colors.base),
                        getMat(z===-1?CONFIG.colors.b:CONFIG.colors.base),
                    ];
                    const cube = new THREE.Mesh(geo, mats);
                    cube.position.set(x*TOTAL_SIZE, y*TOTAL_SIZE, z*TOTAL_SIZE);
                    
                    const edges = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:0x000000, linewidth:2}));
                    cube.add(edges);
                    cubeGroup.add(cube);
                    cubes.push(cube);
                }
            }
        }
    }

    function getMat(c) {
        return new THREE.MeshStandardMaterial({color:c, roughness:0.5, metalness:0.1});
    }

    // --- æ™ºèƒ½åˆ¤å®šç®—æ³• ---
    function checkIsSolved() {
        if (cubes.length === 0 || isFlipped) return false; // é¢ å€’æ¨¡å¼ä¸‹ä¸æ£€æŸ¥è¿˜åŸçŠ¶æ€
        
        const q0 = cubes[0].quaternion;
        const threshold = 0.1;

        for (let i = 1; i < cubes.length; i++) {
            if (cubes[i].quaternion.angleTo(q0) > threshold) {
                return false;
            }
        }
        return true;
    }

    function handleWin() {
        stopTimer();
        isSolved = true;
        document.getElementById('win-overlay').classList.add('show');
        // ç®€å•çš„èƒœåˆ©åŠ¨ç”»ï¼šè®©é­”æ–¹è½¬ä¸€åœˆ
        new TWEEN.Tween(cubeGroup.rotation)
            .to({y: cubeGroup.rotation.y + Math.PI * 2}, 1000)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();
    }

    // --- æ–°å¢ï¼šä¸Šä¸‹é¢ å€’åŠŸèƒ½ ---
    function flipCube() {
        if (isAnimating) return;
        
        isAnimating = true;
        
        // æ˜¾ç¤ºé¢ å€’æ¨¡å¼æç¤º
        const notice = document.getElementById('flip-notice');
        notice.textContent = isFlipped ? "æ­£å¸¸æ¨¡å¼" : "é¢ å€’æ¨¡å¼";
        notice.classList.add('show');
        setTimeout(() => notice.classList.remove('show'), 2000);
        
        // é¢ å€’æ¨¡å¼åˆ‡æ¢
        isFlipped = !isFlipped;
        
        // æ‰§è¡Œ180åº¦ç¿»è½¬åŠ¨ç”»
        const targetRotation = isFlipped ? Math.PI : 0;
        
        new TWEEN.Tween(cubeGroup.rotation)
            .to({x: targetRotation}, 800)
            .easing(TWEEN.Easing.Back.InOut)
            .onStart(() => {
                // å¦‚æœé­”æ–¹åœ¨é¢ å€’å‰æ˜¯å·²è¿˜åŸçŠ¶æ€ï¼Œç°åœ¨æ ‡è®°ä¸ºæœªè¿˜åŸ
                if (isSolved) {
                    isSolved = false;
                    document.getElementById('win-overlay').classList.remove('show');
                }
            })
            .onComplete(() => {
                isAnimating = false;
            })
            .start();
    }

    // --- æ—‹è½¬ä¸åŠ¨ç”» ---

    function doRotate(axis, layer, angle, speed, isUserAction) {
        if (isAnimating) return;
        isAnimating = true;

        if (isUserAction && !isScrambling) {
            if (isSolved && !isFlipped) { // å¦‚æœæ˜¯ä»è¿˜åŸçŠ¶æ€å¼€å§‹ï¼Œç¬¬ä¸€æ­¥é‡ç½®ä¸ºæœªè¿˜åŸï¼ˆé¢ å€’æ¨¡å¼é™¤å¤–ï¼‰
                 isSolved = false;
                 document.getElementById('win-overlay').classList.remove('show');
            }
            startTimer(); // é¢ å€’æ¨¡å¼ä¸‹ä¹Ÿç»§ç»­è®¡æ—¶
            moveCount++;
            document.getElementById('moves').innerText = moveCount;
            moveHistory.push({axis, layer, angle});
        }

        const group = cubes.filter(c => Math.abs(Math.round(c.position[axis]/TOTAL_SIZE) - layer) < 0.1);

        pivot.rotation.set(0,0,0);
        pivot.updateMatrixWorld();
        group.forEach(c => pivot.attach(c));

        new TWEEN.Tween({val:0}).to({val:angle}, speed)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(o => pivot.rotation[axis] = o.val)
            .onComplete(() => {
                pivot.updateMatrixWorld();
                group.forEach(c => {
                    cubeGroup.attach(c);
                    c.position.x = Math.round(c.position.x/TOTAL_SIZE)*TOTAL_SIZE;
                    c.position.y = Math.round(c.position.y/TOTAL_SIZE)*TOTAL_SIZE;
                    c.position.z = Math.round(c.position.z/TOTAL_SIZE)*TOTAL_SIZE;
                    c.rotation.x = Math.round(c.rotation.x/(Math.PI/2))*(Math.PI/2);
                    c.rotation.y = Math.round(c.rotation.y/(Math.PI/2))*(Math.PI/2);
                    c.rotation.z = Math.round(c.rotation.z/(Math.PI/2))*(Math.PI/2);
                    c.updateMatrix();
                });
                pivot.rotation.set(0,0,0);
                isAnimating = false;

                // æ—‹è½¬ç»“æŸåæ£€æŸ¥æ˜¯å¦è¿˜åŸï¼ˆé¢ å€’æ¨¡å¼ä¸‹ä¸æ£€æŸ¥ï¼‰
                if (!isScrambling && !isFlipped && moveCount > 0 && checkIsSolved()) {
                    handleWin();
                }
            }).start();
    }

    // --- äº¤äº’ç³»ç»Ÿ ---
    function onPointerDown(e) {
        if (isAnimating) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
        mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const ints = raycaster.intersectObjects(cubes);

        if (ints.length > 0) {
            controls.enabled = false;
            selectedCube = ints[0].object;
            // è·å–æ³•çº¿å¹¶è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»
            selectedNormal = ints[0].face.normal.clone().transformDirection(selectedCube.matrixWorld).normalize();
            startPoint = {x:e.clientX, y:e.clientY};
        } else {
            controls.enabled = true;
            selectedCube = null;
        }
    }

    function onPointerMove(e) {
        if (!startPoint || !selectedCube || isAnimating) return;
        const dx = e.clientX - startPoint.x;
        const dy = e.clientY - startPoint.y;
        if (Math.sqrt(dx*dx+dy*dy) < 10) return;

        const moveVec = new THREE.Vector2(dx, dy).normalize();
        const axes = [new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)];
        let bestAxis = null, maxDot = 0, moveDir3D = new THREE.Vector3();

        axes.forEach(ax => {
            // å¦‚æœè½´ä¸æ³•çº¿å‡ ä¹å¹³è¡Œï¼Œåˆ™è·³è¿‡
            if (Math.abs(ax.dot(selectedNormal)) > 0.9) return;
            
            // å°†è½´è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»ï¼ˆè€ƒè™‘é­”æ–¹ç»„çš„æ—‹è½¬ï¼‰
            const worldAxis = ax.clone().applyQuaternion(cubeGroup.quaternion).normalize();
            
            // å°†è½´çš„èµ·ç‚¹å’Œç»ˆç‚¹æŠ•å½±åˆ°å±å¹•
            const p1 = project(selectedCube.position);
            const p2 = project(selectedCube.position.clone().add(worldAxis));
            const scrDir = new THREE.Vector2(p2.x-p1.x, p2.y-p1.y).normalize();
            
            const dot = scrDir.dot(moveVec);
            if (Math.abs(dot) > Math.abs(maxDot)) {
                maxDot = dot; 
                bestAxis = ax; 
                moveDir3D = worldAxis.clone().multiplyScalar(Math.sign(dot));
            }
        });

        if (bestAxis) {
            // è®¡ç®—æ—‹è½¬è½´ï¼šæ³•çº¿ Ã— ç§»åŠ¨æ–¹å‘
            const rotAxis = new THREE.Vector3().crossVectors(selectedNormal, moveDir3D).normalize();
            
            // å°†æ—‹è½¬è½´è½¬æ¢å›é­”æ–¹å±€éƒ¨åæ ‡ç³»ï¼Œä»¥ä¾¿ç¡®å®šæ—‹è½¬è½´å’Œæ–¹å‘
            const localRotAxis = rotAxis.clone().applyQuaternion(cubeGroup.quaternion.clone().invert()).normalize();
            
            let aName = 'x', dir = 0;
            // æ‰¾åˆ°ä¸»è¦çš„æ—‹è½¬è½´åˆ†é‡
            if (Math.abs(localRotAxis.x) > Math.abs(localRotAxis.y) && Math.abs(localRotAxis.x) > Math.abs(localRotAxis.z)) {
                aName = 'x'; 
                dir = localRotAxis.x > 0 ? 1 : -1;
            } else if (Math.abs(localRotAxis.y) > Math.abs(localRotAxis.z)) {
                aName = 'y'; 
                dir = localRotAxis.y > 0 ? 1 : -1;
            } else {
                aName = 'z'; 
                dir = localRotAxis.z > 0 ? 1 : -1;
            }

            const layer = Math.round(selectedCube.position[aName]/TOTAL_SIZE);
            doRotate(aName, layer, dir*Math.PI/2, CONFIG.animSpeed, true);
            startPoint = null; selectedCube = null;
        }
    }

    function onPointerUp() { startPoint = null; controls.enabled = true; }
    
    function project(v) { 
        // å°†ç‚¹è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»
        const worldV = v.clone();
        cubeGroup.localToWorld(worldV);
        // æŠ•å½±åˆ°å±å¹•
        const t = worldV.project(camera); 
        return {x:t.x, y:-t.y}; 
    }

    // --- æŒ‰é’®åŠŸèƒ½ ---
    function undoMove() {
        if (isAnimating || moveHistory.length===0 || isScrambling || isSolved) return;
        const last = moveHistory.pop();
        doRotate(last.axis, last.layer, -last.angle, CONFIG.animSpeed, false); 
        if (moveCount > 0) {
            moveCount--;
            document.getElementById('moves').innerText = moveCount;
        }
    }

    function scramble() {
        if (isAnimating) return;
        resetUI();
        isScrambling = true;
        isSolved = false;
        isFlipped = false; // æ‰“ä¹±æ—¶é€€å‡ºé¢ å€’æ¨¡å¼
        moveHistory = [];
        
        // é‡ç½®é­”æ–¹ç»„æ—‹è½¬
        new TWEEN.Tween(cubeGroup.rotation)
            .to({x:0, y:0, z:0}, 300)
            .easing(TWEEN.Easing.Cubic.Out)
            .start();
        
        const axes = ['x','y','z']; const layers = [-1,0,1]; const dirs = [1,-1];
        let count = 0;
        
        function step() {
            if (count >= 20) { 
                isScrambling = false; 
                return; 
            }
            const ax = axes[Math.floor(Math.random()*3)];
            const la = layers[Math.floor(Math.random()*3)];
            const di = dirs[Math.floor(Math.random()*2)];
            doRotate(ax, la, di*Math.PI/2, 60, false);
            setTimeout(() => { count++; step(); }, 70);
        }
        step();
    }

    function resetGame() {
        if (isAnimating) return;
        resetUI();
        isSolved = true;
        isFlipped = false; // é‡ç½®æ—¶é€€å‡ºé¢ å€’æ¨¡å¼
        moveHistory = [];
        
        // é‡ç½®é­”æ–¹ç»„æ—‹è½¬
        cubeGroup.rotation.set(0,0,0);
        
        createCube();
        new TWEEN.Tween(camera.position).to({x:5,y:5,z:7}, 1000).easing(TWEEN.Easing.Cubic.Out).start();
        new TWEEN.Tween(controls.target).to({x:0,y:0,z:0}, 1000).start();
    }

    function onResize() {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate(t) {
        requestAnimationFrame(animate);
        TWEEN.update(t);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>